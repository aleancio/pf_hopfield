
#include <cassert>
#include <cmath>
#include <iostream>

#include "../HopfieldImagePattern/HopfieldImagePattern.hpp"
#include "ModernHopfieldNetwork.hpp"

int main() {
  std::cout << "---- Welcome to the Modern Hopfield Network ----\n";
  std::cout << "---- This is the pattern recognition section. Please follow the instructions below ----\n\n";

  try {
    std::string filePath{"#"};
    std::cout << "---- Welcome to the Modern Hopfield Network ----\n";
    std::cout << "---- This is the pattern recognition section. Please follow the instructions below ----\n\n";
    std::cout << "For demonstration purposes, the memory file used here is the one generated by ModernLearn.\n";
    std::cout << "Please enter the absolute path to the file where memory is stored (type '#' to use the default):\t";

    std::cin >> filePath;

    

    if (filePath == "#") {
      filePath = "ModernMatrixValues.txt";
    }
    abc::ModernHopfieldNetwork net;
    std::cout << "loading memory...\n";
    net.loadMemory(filePath);  // loading values


    std::cout << "\n----------------------------------\n";
    std::cout << "Now we will load a corrupted pattern for recognition and restoration.\n";
    std::cout << "For demonstration purposes, you may use an image from the same set used for training (type '#' to load an example image):\t";
    std::cin >> filePath;


    if (filePath == "#") {
      filePath = "ModernHopfieldNetwork/images/orecchino.png";
    }

    unsigned int patternSize{static_cast<unsigned int>(
        std::sqrt(net.getMatrix().getMatrix()[0].size()))};

    std::cout << patternSize << "\n";
    abc::HopfieldImagePattern pattern(filePath, patternSize);

    pattern.adaptImage_withBilinearInterpolation();
    sf::Texture originalTexture;
    originalTexture.loadFromImage(pattern.printPattern());

    pattern.corrupt(static_cast<size_t>(std::ceil(
        static_cast<double>(patternSize * patternSize) * 0.25)));  // corrupting
    // 35%
    sf::Texture corruptedTexture;
    corruptedTexture.loadFromImage(pattern.printPattern());

    sf::Texture updateTexture(corruptedTexture);

    std::cout << "pattern has been generated and corrupted by 25%\n";
    // setting elements to draw
    sf::Sprite originalSprite(originalTexture);
    sf::Sprite corruptedSprite(corruptedTexture);
    sf::Sprite updateSprite(updateTexture);

    sf::RenderWindow window(sf::VideoMode(800, 600),
                            "Modern Hopfield Network");
    window.setFramerateLimit(1);

    const float windowWidth = 800.0f;
    const float windowHeight = 600.0f;
    const float gap = 75.f;
    sf::Vector2u spriteSize = originalTexture.getSize();
    float imageWidth = static_cast<float>(spriteSize.x);
    float imageHeight = static_cast<float>(spriteSize.y);
    float totalWidth = 3 * imageWidth + 2 * gap;  // spazio tra le immagini
    float startX = (windowWidth - totalWidth) / 2.0f;
    float centerY = (windowHeight - imageHeight) / 2.0f;
    originalSprite.setPosition(startX, centerY);
    corruptedSprite.setPosition(startX + imageWidth + gap, centerY);
    updateSprite.setPosition(startX + 2 * (imageWidth + gap), centerY);

    // Title ecc...
    sf::Font font;
    if (!font.loadFromFile("JAi_____.TTF")) {
      throw std::runtime_error("Problem loading font");
    }

    sf::Text title;
    title.setFont(font);
    title.setFillColor(sf::Color::White);
    title.setString("Restore Pattern");
    title.setCharacterSize(40);
    title.setOrigin(title.getLocalBounds().width / 2.f,
                    title.getLocalBounds().height / 2.f);
    title.setPosition(windowWidth / 2.f, centerY - imageHeight / 2.f - 120.f);
    sf::Text oTitle;
    oTitle.setFont(font);
    oTitle.setFillColor(sf::Color::White);
    oTitle.setString("Original");
    oTitle.setCharacterSize(20);
    oTitle.setOrigin(oTitle.getLocalBounds().width / 2.f,
                     oTitle.getLocalBounds().height / 2.f);
    oTitle.setPosition(startX + imageWidth / 2.f,
                       centerY + imageHeight / 2.f + 70.f);
    sf::Text cTitle;
    cTitle.setFont(font);
    cTitle.setFillColor(sf::Color::White);
    cTitle.setString("Corrupted");
    cTitle.setCharacterSize(20);
    cTitle.setOrigin(cTitle.getLocalBounds().width / 2.f,
                     cTitle.getLocalBounds().height / 2.f);
    cTitle.setPosition(startX + imageWidth + gap + imageWidth / 2.f,
                       centerY + imageHeight / 2.f + 70.f);
    sf::Text uTitle;
    uTitle.setFont(font);
    uTitle.setFillColor(sf::Color::White);
    uTitle.setString("Result");
    uTitle.setCharacterSize(20);
    uTitle.setOrigin(uTitle.getLocalBounds().width / 2.f,
                     uTitle.getLocalBounds().height / 2.f);
    uTitle.setPosition(startX + 2 * (imageWidth + gap) + imageWidth / 2.f,
                       centerY + imageHeight / 2.f + 70.f);
    sf::Text instruction;
    instruction.setFont(font);
    instruction.setFillColor(sf::Color::White);
    instruction.setString("Press C to start restoring ESC to quit");
    instruction.setCharacterSize(32);
    instruction.setOrigin(instruction.getLocalBounds().width / 2.f,
                          instruction.getLocalBounds().height / 2.f);
    instruction.setPosition(windowWidth / 2.f,
                            centerY + imageHeight / 2.f + 120.f);

    sf::Text Entext;
    Entext.setScale(0.7f, 0.7f);
    Entext.setFont(font);
    Entext.setFillColor(sf::Color::White);
    Entext.setString("Press C to start restoring ESC to quit");
    Entext.setCharacterSize(32);
    double Energy = net.energyPerState(pattern.getPattern(), 0);
    net.setTemp0(115);
    Entext.setString("Energy: " + std::to_string(Energy));
    Entext.setOrigin(Entext.getLocalBounds().width / 2.f,
                     Entext.getLocalBounds().height / 2.f);
    Entext.setPosition(windowWidth / 2.f, centerY + imageHeight / 2.f + 190.f);

    bool start{false};
    bool converged{false};
    int nFrames{0};
    int n{0};


    while (window.isOpen()) {
      sf::Event event;
      while (window.pollEvent(event)) {
        if (event.type == sf::Event::Closed) {
          window.close();
        }
        if (event.type == sf::Event::KeyPressed) {
          if (event.key.code == sf::Keyboard::Escape) {
            window.close();
          }
          if (event.key.code == sf::Keyboard::C) {
            start = true;
          }
        }
      }
      window.clear(sf::Color::Black);

      window.draw(title);
      window.draw(oTitle);
      window.draw(uTitle);
      window.draw(cTitle);
      window.draw(instruction);
      window.draw(originalSprite);
      window.draw(corruptedSprite);

      window.draw(Entext);

      if (start) {
        if (!converged) {
 
            converged = net.restorePattern_withAnnealing(pattern.elaboratePattern(), n);
            updateTexture.update(pattern.printPattern());
            updateSprite.setTexture(updateTexture);
  
            assert(net.energyPerState(pattern.getPattern(), n) <= Energy);
                Entext.setString("Energy: " + std::to_string(net.energyPerState(
                                                  pattern.getPattern(), n)));
                  ++n;
        } else {
          start = false;
          std::cout << "\nRestoration complete" << '\n';
        }
      }
      window.draw(updateSprite);
      window.display();
      ++nFrames;
    }

  } catch (std::exception const& e) {
    std::cerr << "Caught exception: '" << e.what() << "'\n";
    return EXIT_FAILURE;
  } catch (...) {
    std::cerr << "Caught unknown exception\n";
    return EXIT_FAILURE;
  }
}